{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>    Automate reproducible packaging for various language ecosystems    Documentation |   Example Repo |   Example Repo Flake |   Example Packages </p> <p>Warning</p> <p>dream2nix is unstable software. While simple UX is one of our main focus points, the APIs  are still under development. Do expect changes that will break your setup.</p>"},{"location":"#legacy-dream2nix","title":"legacy dream2nix","text":"<p>Dream2nix is currently in the process of being refactored to make use of drv-parts. Not all features and subsystems are migrated yet. If you prefer continue using the <code>makeFlakeOutputs</code> interface, please refer to the legacy branch of dream2nix.</p>"},{"location":"#funding","title":"Funding","text":"<p>This project was funded through the NGI Assure Fund, a fund established by NLnet with financial support from the European Commission's Next Generation Internet programme, under the aegis of DG Communications Networks, Content and Technology under grant agreement No 957073. Applications are still open, you can apply today.</p> <p>If your organization wants to support the project with extra funding in order to add support for more languages or new features, please contact one of the maintainers.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>\ud83d\udc49 To the docs</p>"},{"location":"#presentations","title":"Presentations","text":"<ul> <li>\ud83d\udc49 2023: dream2nix based on drv-parts</li> <li>\ud83d\udc49 2021: Original dream2nix presentation (Examples are outdated)</li> </ul>"},{"location":"#get-in-touch","title":"Get in touch","text":"<p>\ud83d\udc49 matrix chat room</p>"},{"location":"#contribute","title":"Contribute","text":"<p>\ud83d\udc49 GitHub repo</p> <p>\ud83d\udc49 issues</p>"},{"location":"#goals","title":"Goals","text":"<p>dream2nix focuses on the following aspects:</p> <ul> <li>Modularity</li> <li>Customizability</li> <li>Maintainability</li> <li>Code de-duplication across 2nix solutions</li> <li>Common UI across 2nix solutions</li> <li>Reduce effort to develop new 2nix solutions</li> <li>Exploration and adoption of new nix features</li> <li>Simplified updating of packages</li> </ul> <p>The goal of this project is to create a standardized, generic, modular framework for automated packaging solutions, aiming for better flexibility, maintainability and usability.</p> <p>The intention is to integrate many existing 2nix converters into this framework, thereby improving many of the previously named aspects and providing a unified UX for all 2nix solutions.</p>"},{"location":"docs/","title":"About this Documentation","text":"<p>Dream2nix documentation is generated from markdown via  mkdocs and mkdocs-material.</p>"},{"location":"docs/#build","title":"Build","text":"<p>You can build and server it locally with, i.e.:</p> <pre><code>nix build .#website\npython3 -m http.server -d ./result\n</code></pre>"},{"location":"docs/#development-shell","title":"Development shell","text":"<p>Or alternatively run a development environment with:</p> <pre><code>nix develop .#website\n</code></pre> <p>Upon entering the devshell, it will change into <code>./docs</code> and symlink a build of the options reference into <code>./docs/src/reference</code>. </p> <p>Normal builds will always use an up-to-date options reference, but during development you need to update this symlink yourself and remove it after use. </p> <p>i.e. from inside the shell in <code>./docs</code>:</p> <pre><code># update\nln -sfT $(nix build --print-out-paths --no-link .#optionsReference) ./src/reference\n# remove\nrm ./src/reference\n</code></pre>"},{"location":"docs/#options-reference","title":"Options Reference","text":"<p>The reference documentation for modules is auto-generated via a custom hook in <code>docs/hooks/render_options.py</code> and a derivation in <code>.#optionsReference</code>. </p> <p>The derivation includes, for each module, an <code>options.json</code> file as generated by nix via <code>pkgs.nixosOptionsDoc</code> as well as a <code>README.md</code> file, copied from the modules source directory. The existence of such a <code>README.md</code> is used as an indicator on whether to include a module in the reference documentation.</p> <p>The hook runs whenever mkdocs renders one of the <code>README.md</code>s. Each of them gets concatenated with header and options reference, after the latter are run through jinja templates in <code>./docs/theme</code>.</p>"},{"location":"docs/#notes-on-markdown","title":"Notes on Markdown","text":"<p>Mkdocs uses a markdown dialect from Python-Markdown with various, optional extensions listed in <code>./docs/mkdocs.yml</code>.</p> <p>This is different from the CommonMark dialect, as implemented by markdown-it-py and used in NixOS official documentation.</p> <p>The differences between both don't seem to be too relevant for the markdown features used in our options reference, but it's good to be aware of them when writing longer prose.</p> <p>mkdocs-materials reference provides a good overview on useful extensions.</p>"},{"location":"docs/#ci","title":"CI","text":"<p>The documentation is published on GitHub pages via a GitHub action, defined in .github/workflows/pages.yml</p>"},{"location":"modules/","title":"Why Modules?","text":"<p>Declaring derivations as modules solves a number of issues.</p> <p>For some more background information, check out the initial exploration of this idea at DavHau/pkgs-modules.</p> <p>@edolstra 's talk about this topic is also worth watching.</p>"},{"location":"modules/#benefits","title":"Benefits","text":""},{"location":"modules/#deprecate-override-functions","title":"Deprecate override functions","text":"<p>Changing options of packages in nixpkgs can require chaining different override functions like this:</p> <pre><code>{\n  htop-mod = let\n    htop-overridden = pkgs.htop.overrideAttrs (old: {\n      pname = \"htop-mod\";\n    });\n  in\n    htop-overridden.override (old: {\n      sensorsSupport = false;\n    });\n}\n</code></pre> <p>... while doing the same using <code>dream2nix</code> looks like this:</p> <pre><code>{\n  htop-mod = {\n    imports = [./htop.nix];\n    name = lib.mkForce \"htop-mod\";\n    flags.sensorsSupport = false;\n  };\n}\n</code></pre> <p>See htop module definition here.</p>"},{"location":"modules/#type-safety","title":"Type safety","text":"<p>The following code in nixpkgs mkDerivation mysteriously skips the patches:</p> <pre><code>mkDerivation {\n  # ...\n  dontPatch = \"false\";\n}\n</code></pre> <p>... while doing the same using <code>dream2nix</code> raises an informative type error:</p> <pre><code>A definition for option `[...].dontPatch' is not of type `boolean' [...]\n</code></pre>"},{"location":"modules/#catch-typos","title":"Catch typos","text":"<p>The following code in nixpkgs mkDerivation builds without openssl_3.</p> <pre><code>mkDerivation {\n  # ...\n  nativBuildInputs = [openssl_3];\n}\n</code></pre> <p>... while doing the same using <code>dream2nix</code> raises an informative error:</p> <pre><code>The option `[...].nativBuildInputs' does not exist\n</code></pre>"},{"location":"modules/#environment-variables-clearly-defined","title":"Environment variables clearly defined","text":"<p><code>dream2nix</code> requires a clear distinction between known parameters and user-defined variables. Defining <code>SOME_VARIABLE</code> at the top-level, would raise:</p> <pre><code>The option `[...].SOME_VARIABLE' does not exist\n</code></pre> <p>Instead it has to be defined under <code>env.</code>:</p> <pre><code>{\n  my-package = {\n    # ...\n    env.SOME_VARIABLE = \"example\";\n  };\n}\n</code></pre>"},{"location":"modules/#documentation-discoverability","title":"Documentation / Discoverability","text":"<p>No more digging the source code to find possible options to override.</p> <p>Documentation similar to search.nixos.org can be generated for packages declared via <code>dream2nix</code>.</p> <p>Every package built with <code>dream2nix</code> has a <code>.docs</code> attribute that builds an html documentation describing it's options.</p>"},{"location":"modules/#package-blueprints","title":"Package blueprints","text":"<p>With <code>dream2nix</code>, packages don't need to be fully declared. Options can be left without defaults, requiring the consumer to complete the definition.</p>"},{"location":"modules/#flexibility","title":"Flexibility","text":"<p>The nixos module system gives maintainers more freedom over how packages are split into modules. Separation of concerns can be implemented more easily. For example, the dependency tree of a package set can be factored out into a separate module, allowing for simpler modification.</p>"},{"location":"overrides/","title":"Overriding Dependencies in Dream2nix","text":"<p>Dream2nix automates the generation of build instructions for packages, including their dependencies. Occasionally, these instructions may require manual adjustments, called overrides, in situations where:</p> <ul> <li>A package fails to build.</li> <li>A package does not function as expected.</li> <li>A package needs to be compiled with specific features.</li> </ul> <p>There are three primary methods to override dependencies in dream2nix:</p> <ul> <li>Global Overrides: Configured via <code>overrideAll</code>, affecting all dependencies of the current package.</li> <li>Local Overrides: Configured via <code>overrides.${name}</code>, targeting dependencies with a specific name.</li> <li>Community Overrides: Predefined in dream2nix, applied automatically to relevant dependencies.</li> </ul>"},{"location":"overrides/#global-overrides","title":"Global Overrides","text":"<p>Global overrides apply universally to all dependencies within a specific language module in dream2nix. For instance, the Python <code>pip</code> module provides a <code>pip.overrideAll</code> option. This is particularly useful for modifying global defaults across all dependencies managed by the module.</p>"},{"location":"overrides/#global-overrides-example","title":"Global Overrides Example","text":"<p>By default, the <code>pip</code> module disables testing for dependencies. To enable testing globally, use <code>overrideAll</code> as shown below:</p> <pre><code>{config, lib, ...}: {\n  pip.overrideAll.mkDerivation.doCheck = true;\n}\n</code></pre>"},{"location":"overrides/#local-overrides","title":"Local Overrides","text":"<p>Local overrides are specific to individual packages. This method allows for precise control over the build instructions for certain packages.</p>"},{"location":"overrides/#local-overrides-example","title":"Local Overrides Example","text":"<p>The following override applies exclusively to the <code>opencv-python</code> package, ensuring specific build dependencies are included:</p> <pre><code>{config, lib, ...}: {\n  pip.overrides.opencv-python = {\n    env.autoPatchelfIgnoreMissingDeps = true;\n    mkDerivation.buildInputs = [\n      pkgs.libglvnd\n      pkgs.glib\n    ];\n  };\n}\n</code></pre> <p>Note: For ecosystems like Node.js that may include multiple versions of a dependency, local overrides affect all versions by default. For version-specific overrides, refer to the Conditionals section.</p>"},{"location":"overrides/#community-overrides","title":"Community Overrides","text":"<p>Community overrides are akin to local overrides but are provided with dream2nix, applying automatically to their respective dependencies. They represent collective knowledge and fixes for common issues contributed by the user community.</p>"},{"location":"overrides/#contributing-to-community-overrides","title":"Contributing to Community Overrides","text":"<p>To contribute your overrides to the community, add them to the dream2nix source tree under <code>/overrides/{language}/{dependency-name}/default.nix</code>. Each dependency within an ecosystem should have its own override file. This structure ensures automatic application of these overrides during dependency resolution.</p>"},{"location":"overrides/#conditionals","title":"Conditionals","text":"<p>Conditional overrides offer flexibility by allowing overrides to be applied based on specific criteria, such as dependency versions or feature flags.</p>"},{"location":"overrides/#conditionals-example","title":"Conditionals Example","text":"<p>The following conditional override disables tests for versions of the <code>pillow</code> package version <code>10.0.0</code> or higher:</p> <pre><code>{config, lib, ...}: {\n  pip.overrides.pillow = {\n    mkDerivation.doCheck =\n      if lib.versionAtLeast \"10.0.0\" config.version\n      then false\n      else true;\n  };\n}\n</code></pre>"},{"location":"overrides/#list-of-options","title":"List of Options","text":"<p>Different dream2nix modules offer different options to override. Refer to the documentation of the specific language module to see the options. Alternatively enter <code>{module-name}.overrides</code> into the documentation search.</p>"},{"location":"development-roundups/2022-april-june/","title":"Development Roundup April - June 2022","text":"<p>In the period of 3 months, 40 pull requests were merged.</p>"},{"location":"development-roundups/2022-april-june/#most-notable-changes","title":"Most Notable Changes","text":""},{"location":"development-roundups/2022-april-june/#extension-interface-for-subsystem-modules","title":"Extension Interface for subsystem modules","text":"<p>Dream2nix now has an extension interface which allows users to add support for other ecosystems and lock file formats out of tree. This allows people to maintain private dream2nix extensions or publish their extensions on their own repositories. For the future it is planned to go one step further and use the nixos module system for dream2nix.</p>"},{"location":"development-roundups/2022-april-june/#improved-handling-of-mono-repo-projects","title":"Improved handling of mono-repo projects","text":"<p>Many software projects in the wild consist of several sub-project. The sub-projects could be of the same ecosystem, like a nodejs project managed by npm, declaring several workspaces, or they could be of completely different ecosystems, like a nodejs project, containing a rust and a go module within the same source tree. A goal for dream2nix is to handle all these constellations well, to provide the user with decent automation and interfaces in order to simplify working with these complex software projects as much as possible. Therefore a discovery mechanism has been established and improved over time to tackle mono-repo scenarios, detecting sub-projects of arbitrary type within a larger source tree, splitting the detected projects into reasonable chunks of work that can be processed by many different translator modules of dream2nix.</p>"},{"location":"development-roundups/2022-april-june/#unit-tests-for-pure-translators","title":"Unit tests for pure translators","text":"<p>Pure translators are the parts of dream2nix which are able to read upstream lock files and other metadata and convert this data to the dream2nix internal dream-lock format. All of this in done in pure nix without calling to external programs. For example the cargo-lock translator allows dream2nix to just build any rust project on-the-fly, given just the source code of the project. In order for dream2nix to extend its support onto many more ecosystems, we rely on the community contributions adding pure translators. For this reason we want to make such contributions as simple as possible. This is why we established a unit testing suit for pure translators. This is realized by using python + pytest to define the unit tests which then call out to nix via our python nix-ffi. This allows people to implement new translators step by step while getting constant feedback if they are on the right track.</p>"},{"location":"development-roundups/2022-april-june/#more-changes","title":"More Changes","text":"<ul> <li>Reorganized internal code structure of <code>dream2nix</code> (<code>builders</code>, <code>translators</code>, <code>discoverers</code> moved to <code>subsystems</code>)</li> <li>New community overrides to fix some nodejs packages</li> <li>Improved usage examples in readme</li> <li>Improvements on several subsystems including nodejs and rust</li> <li> <p>New documentation website: https://dream2nix.dev/</p> </li> <li> <p>Added subsystems:</p> </li> <li>python</li> <li>haskell</li> <li>Added support for translating formats:</li> <li>python: setup.py</li> <li>haskell: stack.yaml.lock (stack)</li> <li>haskell: plan.json (cabal)</li> <li>rust: Cargo.toml, Cargo.lock</li> <li>Added builders for:</li> <li>haskell: <code>default</code></li> </ul>"},{"location":"development-roundups/2022-april-problems-of-nixos-module-system/","title":"Thoughts on the current nixos module system","text":"<p>This document covers observed problems with the current nixos module system that arose after using it for dream2nix and proposes changes to the module system.</p>"},{"location":"development-roundups/2022-april-problems-of-nixos-module-system/#problem-1-bad-control-over-module-dependencies","title":"Problem 1: Bad control over module dependencies","text":"<p>It is easy to depend on a module unintentionally.</p> <p>It is hard to guarantee that a module works with a limited set of other modules.</p> <p>A module can import arbitrary paths, which makes it hard to limit the modules of the evaluation.</p>"},{"location":"development-roundups/2022-april-problems-of-nixos-module-system/#problem-2-module-identificationduplication-issues","title":"Problem 2: Module identification/duplication issues","text":"<p>References to the same module in different ways (file vs imported file), are sometimes accidentally detected as two different modules leading to a collision error.</p> <p>It is possible to prevent this by setting <code>_file</code>, but this still not optimal, as not all modules are forced to define this field. Not having a unique ID by default is not optimal.</p>"},{"location":"development-roundups/2022-april-problems-of-nixos-module-system/#problem-3-result-type-and-location-not-discoverable","title":"Problem 3: Result type and location not discoverable","text":"<p>Usually the evaluation of a set of modules leads to a result or a set of results. But neither the type of the result nor the location of the result within <code>config</code> can be discovered by the caller without looking at the modules implementation.</p> <p>For example NixOS exports the results via <code>config.system</code>, drv-parts uses <code>config.public</code> etc. For the user calling <code>evalModules</code> it is not clear how exactly to get to the final result out of the evaluation.</p> <p>Strictly speaking, the result is the <code>config</code>, but apart from the final result, <code>config</code> also contains other things, like user interfaces and intermediary result. This confuses a user who is only interested in the final result.</p>"},{"location":"development-roundups/2022-april-problems-of-nixos-module-system/#problem-4-unprotected-gloabl-scope","title":"Problem 4: Unprotected gloabl scope","text":"<p>Using the global scope to pass data between modules is not optimal, because: - collisions: option declarations and definitions of different modules can collide accidentally. - unlimited access: A module can read and write to arbitrary fields of arbitrary other modules by default. This can result in unwanted side effects and hidden dependencies on other modules. Even if a module doesn't declare a dependency on module X it can depend on module X setting some option of module Y correctly. These unwanted interactions can be very complex and hard to find and prevent.</p> <p>Considered workaround: We established the following pattern:</p> <ul> <li>Each module prefixes all its options with the modules name, for example:</li> <li>module <code>mkDerivation</code> defines options <code>mkDerivation.src</code> and <code>mkDerivation.buildPhase</code></li> <li>module <code>buildPythonPackages</code> defines options <code>buildPythonPackage.format</code> ...</li> </ul> <p>Benefit of the workaround: This prevents collisions (assuming module names are unique)</p> <p>Disadvantage of the workaround:</p> <ul> <li>It still allows global read/write access between all modules.</li> <li>It prevents composition of interfaces: We cannot nicely mix the options of <code>mkDerivation</code> and <code>buildPythonPackage</code> to create a new module, as all options have a hardcoded prefix that cannot be changed anymore</li> <li>Using the module as submodule is more annoying, as because of the hardcoded prefix, it always adds an additional layer of nesting that might not be desired.</li> </ul>"},{"location":"development-roundups/2022-april-problems-of-nixos-module-system/#proposal-1","title":"Proposal 1","text":"<p>Solves:</p> <ul> <li>Problem 1 (Bad control over module dependencies)</li> <li>Problem 2 (Module identification/duplication issues)</li> </ul> <p>Proposed Changes:</p> <ul> <li>generally separate <code>dependency declaration</code> from <code>dependency satisfaction</code></li> <li>for example, add a flag to evalModules that changes the behavior of <code>imports</code></li> <li>force modules to declare <code>imports</code> by name (never by path)</li> <li>have a <code>resolver</code> resolving requested names against a set of named modules provided by the user</li> <li>allow inspecting the requested dependencies before evaluation</li> </ul> <p>Effects:</p> <ul> <li>users can discover module dependencies</li> <li>users can override the resolved module and thereby replace it's implementation</li> <li>maintainers can discover and prevent hidden dependencies easily</li> <li>lay the grounds for better input management (derive flake inputs from modules)</li> </ul>"},{"location":"development-roundups/2022-april-problems-of-nixos-module-system/#proposal-2","title":"Proposal 2","text":"<p>Solves:</p> <ul> <li>Problem 3 (Result type and location not discoverable)</li> </ul> <p>Proposed Changes:</p> <ul> <li>standardize a specific field under config to contain the final result(s), like for example <code>config.exports</code>.</li> </ul> <p>Effects:</p> <ul> <li>the result type is discoverable by inspecting the type of <code>options.exports</code></li> <li>allows adding helper <code>callModule</code> which is like <code>evalModules</code> but just returns the result.</li> <li>allows users to treat modules like functions that can be called and return a result.</li> <li>modules are more approachable by high-level users</li> <li>modules are more portable.</li> </ul>"},{"location":"development-roundups/2022-april-problems-of-nixos-module-system/#proposal-3","title":"Proposal 3","text":"<p>Solves:</p> <ul> <li>Problem 4 (Unprotected global scope)</li> </ul> <p>Proposed Changes:</p> <ul> <li>disallow nested option declarations</li> <li>disallow inline definitions for submodules</li> </ul> <p>(This limitation could be toggled via a flag in evalModules)</p> <p>Effects:</p> <ul> <li>This forces maintainers to use submodules (defined in files) to create nested options</li> <li>This leads to an extensive use of submodules</li> <li>Using submodules encourages passing information explicitly between modules while discouraging the use of global fields for communication</li> </ul>"},{"location":"development-roundups/2022-july-september/","title":"Development Roundup July - September 2022","text":"<p>In the period of 3 months, 62 pull requests were merged.</p>"},{"location":"development-roundups/2022-july-september/#most-notable-changes","title":"Most Notable Changes","text":""},{"location":"development-roundups/2022-july-september/#indexers","title":"Indexers","text":"<p>Dream2nix now offers an interface for defining <code>indexers</code>. Indexers are programs that can query a package repository (think of npm, or crates.io) for package information.</p> <p>Indexers can be used to automatically import packages from all kinds of ecosystems into the nix domain. For example the <code>libraries-io</code> indexer can be used to query libraries.io for the 5000 most popular nodejs packages and convert them to nix packages.</p> <p>One nice use case for indexers is to test dream2nix by continuously building large auto generated package sets while monitoring the success rate and get useful information from build failures.</p> <p>Currently we already have this testing infrastructure set up for nodejs and rust (more will be added soon). The package sets can be found in the repo: nix-community/dream2nix-auto-test</p>"},{"location":"development-roundups/2022-july-september/#development-shells","title":"development shells","text":"<p>Besides the usual packages, many builders in dream2nix do now also output dev-shell(s) via the <code>devShells</code> attribute. This should allow developers to quickly spin up a shell environment on arbitrary projects with the required dependencies available to start hacking.</p>"},{"location":"development-roundups/2022-july-september/#begin-moving-to-nixos-module-system","title":"Begin moving to nixos module system","text":"<p>We started a larger refactoring effort, separating dream2nix internals into nixos modules. The goal of this undertaking is to gain:</p> <ul> <li>better flexibility within the framework. People should have an easier time to modify and extend the framework</li> <li>type safety between important components of dream2nix</li> <li>type checked and automatically documented user interfaces (similar to search.nixos.org for nixos)</li> <li>better integration into nixos itself</li> </ul> <p>This is only partially complete yet, as we have to refactor module by module carefully while making sure to not break the current API. Currently, only translators, fetchers, builders and discoverers use the module system. Once the internals are <code>modularized</code>, the final piece of work will be creating a new user interface using nixos modules as well.</p>"},{"location":"development-roundups/2022-july-september/#more-changes","title":"More Changes","text":"<ul> <li>Improvements on several subsystems including haskell, nodejs, python, rust</li> <li>Improvements of some community overrides</li> <li>Added quick start guides to the documentation</li> <li>Several improvements for the documentation</li> <li> <p>Added integration tests</p> </li> <li> <p>Added subsystems:</p> </li> <li>debian</li> <li>php</li> <li>Added support for translating formats:</li> <li>debian: debian-binary (impure)</li> <li>php: composer-lock  (pure)</li> <li>haskell: hackage (impure) - given a package name, retrieve metadata from hackage</li> <li>Added builders for:</li> <li>debian <code>simple-debian</code>: download and patch binary releases from debian repos</li> <li>php <code>simple-php</code>: build dependencies in a combined derivation</li> <li>php <code>granular-php</code>: build dependencies in separate derivations</li> <li>Added indexers:</li> <li>libraries-io: queries libraries.io for package sets</li> </ul>"},{"location":"guides/getting-started/","title":"Getting started","text":"<p>Info</p> <p>We assume that you already got a flakes-enabled nix installed and at least a basic understanding of nix and flakes here.</p> <p>If that's not the case, check out the official documentation site at nix.dev first!</p> <p>In this tutorial, we are going to package GNU hello, a traditional example for build systems, in order to get started with dream2nix and its module system .</p>"},{"location":"guides/getting-started/#start-a-project","title":"Start a project","text":"<p>We start by creating a new git repository with the following two files:</p> <ul> <li> <p><code>flake.nix</code> declares our inputs, dream2nix and nixpkgs, as well as a single package <code>hello</code> as an output.   The package is declared by calling <code>dream2nix.lib.evalModules</code> with the definitions in <code>hello.nix</code>, nixpkgs   and a helper module to let dream2nix know about your directory layout.</p> </li> <li> <p><code>hello.nix</code> declares a dream2nix module that imports mkDerivation and   uses that to build GNU hello.</p> </li> </ul> <p>Check out the code below and don't miss the annotations, hidden behind those little plusses, to learn more!</p> <p>Note</p> <p>And do not hesitate to message us on matrix: #dream2nix:nixos.org if you found a mistake or if things are unclear!</p>"},{"location":"guides/getting-started/#flakenix","title":"<code>flake.nix</code>","text":"flake.nix<pre><code>{\n  description = \"A flake for my dream2nix packages\";\n\n  inputs = { # (1)\n    dream2nix.url = \"github:nix-community/dream2nix\";\n    nixpkgs.follows = \"dream2nix/nixpkgs\";\n  };\n\n  outputs = {\n    self,\n    dream2nix,\n    nixpkgs,\n  }:\n  let\n    eachSystem = nixpkgs.lib.genAttrs [ # (2)\n      \"aarch64-darwin\"\n      \"aarch64-linux\"\n      \"x86_64-darwin\"\n      \"x86_64-linux\"\n    ];\n  in {\n    packages = eachSystem (system: {\n      hello = dream2nix.lib.evalModules { # (3)\n        packageSets.nixpkgs = nixpkgs.legacyPackages.${system}; # (4)\n        modules = [\n          ./hello.nix # (5)\n          { # (6)\n            paths.projectRoot = ./.;\n            paths.projectRootFile = \"flake.nix\";\n            paths.package = ./.;\n          }\n        ];\n      };\n      default = self.packages.${system}.hello;  # (7)\n    });\n  };\n}\n</code></pre> <ol> <li>Import dream2nix and tell nix to use whatever version of nixpkgs dream2nix declares. You can use other versions, but this it what we run our automated tests with.</li> <li>Define a helper function that allows us to reduce boilerplate and still support all of of the listed systems for our package.</li> <li>Create our package, called <code>hello</code> here, by evaluating the given dream2nix modules.</li> <li>Pass the given instance of nixpkgs to build our package with as a module argument.</li> <li>Include our package definition from <code>hello.nix</code>. See below for its contents!</li> <li>Define relative paths to aid dream2nix to find lock files and so on during evaluation time. These settings should work for repos containing multiple python projects as simpler ones.</li> <li>We declare <code>hello</code> to be the default package. This allows us to just call i.e. <code>nix build .#</code> instead of <code>nix build .#hello</code>.</li> </ol>"},{"location":"guides/getting-started/#hellonix","title":"<code>hello.nix</code>","text":"hello.nix<pre><code>{ # (1)\n  dream2nix,\n  config,\n  lib,\n  ...\n}: {\n  imports = [\n    dream2nix.modules.dream2nix.mkDerivation # (2)\n  ];\n\n  # (3)\n  name = \"hello\";\n  version = \"2.12.1\";\n\n  # (4)\n  mkDerivation = {\n    src = builtins.fetchTarball {\n      url = \"https://ftp.gnu.org/gnu/hello/hello-${config.version}.tar.gz\";\n      sha256 = \"sha256-jZkUKv2SV28wsM18tCqNxoCZmLxdYH2Idh9RLibH2yA=\";\n    };\n  };\n}\n</code></pre> <ol> <li>Define a function, taking our module arguments and returning a module.    Inputs include <code>dream2nix</code>, a reference to package itself in <code>config</code>, and the nixpkgs library in <code>lib</code>.</li> <li>Import the <code>mkDerivation</code> module.</li> <li>Define <code>name</code> and <code>version</code> of the package. Unlike most other options, those are not namespaced and defined in dream2nix <code>core</code> module.</li> <li>Define module options to further customize your build. In this case we just set <code>mkDerivation.src</code> to fetch a source tarball as well.    But you could use other arguments from <code>pkgs.mkDerivation</code>, such as <code>buildInputs</code> or <code>buildPhase</code> here as well.</li> </ol>"},{"location":"guides/getting-started/#build-it","title":"Build it","text":"<p>Warning</p> <p>Be aware that nix will only \"see\" your files once they have been added to git's index, i.e. via <code>git add</code>!</p> <p>This is because nix copies flakes to <code>/nix/store</code> before evaluating them, but only those which are tracked by git. This can lead to confusion if nix errors hint at missing files while you are able to seem them in your shell.</p> <p>With all that code added, building it should work like any other nix build:</p> <pre><code>$ git init\n$ git add flake.nix hello.nix\n$ nix build .#  # (1) \n$ ./result/bin/hello\nHello, World!\n</code></pre> <ol> <li><code>.#</code> is a shorter form of <code>.#packages.x86_64-linux.default</code> (on <code>x86_64-linux</code> systems).</li> </ol>"},{"location":"guides/getting-started/#lock-it","title":"Lock it","text":"<p>Some of our our modules such as pip require a custom lock file added to your repository in order to pin your dependencies and store metadata which we can't acquire during evaluation time.</p> <p>We don't need one in the <code>hello</code> example above. If you add a dream2nix module that does, you will receive an error during building, with the error message telling you the command you need to run. Generally:</p> <pre><code>$ nix run .#default.lock\n$ git add lock.json\n</code></pre>"},{"location":"guides/getting-started/#going-further","title":"Going further","text":"<p>Check out our guides, the reference documentation and examples to learn more about the various modules and options to learn more about language-specific helpers to package and distribute your software with dream2nix.</p> <p>Once you have imported a module, this module will make ecosystem-dependent functions, such as <code>mkDerivation</code> or <code>buildPythonPackage</code>, available to your package modules.</p> <p>And don't forget to join our communities at matrix: #dream2nix:nixos.org and github: nix-community/dream2nix to ask questions and learn from each other. Feedback we receive there helps us to improve code &amp; documentation as we go.</p>"},{"location":"guides/pip/","title":"Build a python project with pip","text":"<p>Info</p> <p>We recommend reading our Getting Started guide first if you have not done so yet!</p> <p>In this guide we are going to take a look at two annotated examples using the pip module:</p> <ul> <li>The first one builds Pillow from upstream sources fetched from PyPi.</li> <li>The second one builds a fictional python project living in the same repository as the nix sources   and a development environment around it.</li> </ul>"},{"location":"guides/pip/#start-with-a-flake","title":"Start with a flake","text":"<p>We start both examples by creating a new git repository and adding almost the same <code>flake.nix</code> template we already used in Getting Started. The only difference are the packages name, <code>default</code> instead of <code>hello</code>:</p> flake.nix<pre><code>{\n  inputs = {\n    dream2nix.url = \"github:nix-community/dream2nix\";\n    nixpkgs.follows = \"dream2nix/nixpkgs\";\n  };\n\n  outputs = {\n    self,\n    dream2nix,\n    nixpkgs,\n  }:\n  let\n      eachSystem = nixpkgs.lib.genAttrs [\n      \"aarch64-darwin\"\n      \"aarch64-linux\"\n      \"x86_64-darwin\"\n      \"x86_64-linux\"\n    ];\n  in {\n    packages = eachSystem (system: {\n      default = dream2nix.lib.evalModules { # (1)\n        packageSets.nixpkgs = nixpkgs.legacyPackages.${system};\n        modules = [\n          ./default.nix # (2)\n          {\n            paths.projectRoot = ./.;\n            paths.projectRootFile = \"flake.nix\";\n            paths.package = ./.;\n          }\n        ];\n      };\n    });\n  };\n}\n</code></pre> <ol> <li>We call our package attribute <code>default</code> here...</li> <li>...and the nix file <code>default.nix</code> here.</li> </ol>"},{"location":"guides/pip/#example-pillow","title":"Example: Pillow","text":"<p>Things get a bit more interesting in <code>default.nix</code> where we define a package module which fetches Pillow from pypi and builds it with minimal features - just JPEG support. Click the plus to expand any code annotation below for details. The code we are going to end up with is also available in ./examples/packages/languages/python-packaging-pillow.</p>"},{"location":"guides/pip/#code","title":"Code","text":"default.nix<pre><code>{\n  config,\n  lib,\n  dream2nix,\n  ...\n}: {\n  imports = [\n    dream2nix.modules.dream2nix.pip # (1)\n  ];\n\n  deps = {nixpkgs, ...}: {\n    python = nixpkgs.python3; # (2)\n    inherit # (3)\n      (nixpkgs)\n      pkg-config\n      zlib\n      libjpeg\n      ;\n  };\n\n  name = \"pillow\"; # (4)\n  version = \"10.4.0\";\n\n  mkDerivation = { # (5)\n    nativeBuildInputs = [\n      config.deps.pkg-config\n    ];\n    propagatedBuildInputs = [\n      config.deps.zlib\n      config.deps.libjpeg\n    ];\n  };\n\n  buildPythonPackage = { # (6)\n    pythonImportsCheck = [\n      \"PIL\"\n    ];\n  };\n\n  pip = {\n    requirementsList = [\"${config.name}==${config.version}\"]; # (7)\n    pipFlags = [ # (8)\n      \"--no-binary\"\n      \":all:\"\n    ];\n  };\n}\n</code></pre> <ol> <li>Import the dream2nix pip module into our module.</li> <li>Declare external dependencies, like the python interpreter to use and libraries from nixpkgs. We use whatever the latest <code>python3</code> in nixpkgs is as our python.</li> <li>Declare which build tools we need to pull from nixpkgs for use in <code>mkDerivation</code> below.</li> <li>Declare name and version of our package. Those will also be used for <code>pip.requirementsList</code> below.</li> <li>Set dependencies, <code>pkg-config</code> is only required during build-time, while the libraries should be propagated. We use <code>config.deps</code> instead of a conventional <code>pkg</code> here to be able to \"override\" inputs via the module system.</li> <li>Tell the buildPythonPackage module to verify that it can import the given python module from our package after a build.</li> <li>Tell the pip module which dependencies to lock using the same syntax as  a <code>requirements.txt</code> file. Here: <code>pillow==10.4.0</code>.</li> <li><code>pip</code> uses binary wheel files if available by default. We will not do so in order to ensure a build from source.</li> </ol>"},{"location":"guides/pip/#initialise-the-repostory","title":"Initialise the repostory","text":"<p>If you use <code>git</code>, you need to add <code>flake.nix</code> and <code>default.nix</code> to your git index so that they get copied to the <code>/nix/store</code> and the commands below see them:</p> <pre><code>$ git init\n$ git add flake.nix default.nix\n</code></pre>"},{"location":"guides/pip/#create-a-lock-file","title":"Create a lock file","text":"<p>The next step is to create a lock file by running the packages <code>lock</code> attribute. This does a <code>pip install --dry-run</code> under the hood and pins the exact packages pip would install.</p> <pre><code>$ nix run .#default.lock\n$ git add lock.json\n</code></pre> <p>Note</p> <p>Due to limitations in <code>pip</code>s cross-platform support, the resulting lock-files are platform-specific! We therefore recommend setting <code>paths.lockFile</code> to <code>lock.${system}.json</code> for all projects where you use the pip module.</p> <p>Check out the pdm module if you need a solution that allows locking for multiple platforms at once!</p>"},{"location":"guides/pip/#build-it","title":"Build it","text":"<p>After that's done, we can finally build it:</p> <pre><code>$ nix build .#default\n</code></pre> <p>Congratulations, you just built your first python package with dream2nix! The resulting package can be used with any other nix python package as long as it uses the same version of python.</p>"},{"location":"guides/pip/#example-my-tool","title":"Example: my-tool","text":"<p>In our second example, we package are going to package a simple, fictional python package called <code>my_tool</code>. Its code and nix expressions are stored in the same repository. For reference, they are  available in full in ./examples/packages/languages/python-local-development.</p>"},{"location":"guides/pip/#code_1","title":"Code","text":"default.nix<pre><code>{\n  config,\n  lib,\n  dream2nix,\n  ...\n}: let\n  pyproject = lib.importTOML (config.mkDerivation.src + /pyproject.toml); # (1)\nin {\n  imports = [\n    dream2nix.modules.dream2nix.pip # (2)\n  ];\n\n  deps = {nixpkgs, ...}: {\n    python = nixpkgs.python3; # (3)\n  };\n\n  inherit (pyproject.project) name version; # (4)\n\n  mkDerivation = {\n    src = lib.cleanSourceWith { # (5)\n      src = lib.cleanSource ./.;\n      filter = name: type:\n        !(builtins.any (x: x) [\n          (lib.hasSuffix \".nix\" name)\n          (lib.hasPrefix \".\" (builtins.baseNameOf name))\n          (lib.hasSuffix \"flake.lock\" name)\n        ]);\n    };\n  };\n\n  buildPythonPackage = {\n    pyproject = true;  # (6)\n    pythonImportsCheck = [ # (7)\n      \"my_tool\"\n    ];\n  };\n\n  pip = {\n    # (8)\n    requirementsList =\n      pyproject.build-system.requires or []\n      ++ pyproject.project.dependencies or [];\n\n    flattenDependencies = true; # (9)\n\n    overrides.click = { # (10)\n      buildPythonPackage.pyproject = true;\n      mkDerivation.nativeBuildInputs = [config.deps.python.pkgs.flit-core];\n    };\n  };\n}\n</code></pre> <ol> <li>Load <code>pyproject.toml</code> from our source directory, which is the filtered source defined in <code>mkDerivation.src</code> below.</li> <li>Import the dream2nix pip module into our module</li> <li>Define external, non-python dependencies. We use whatever the latest <code>python3</code> in nixpkgs is as our python.</li> <li>Get our projects <code>name</code> and <code>version</code> straight from <code>pyproject.toml</code>. You could of course also hard-code them here if e.g. your project still uses <code>setup.py</code>.</li> <li>Define the source for our project. Here we take the current directory, but filter out <code>*.nix</code> files, hidden files and <code>flake.lock</code> before copying to <code>/nix/store</code> in order to avoid unecessary rebuilds.</li> <li>Tell the dream2nix buildPythonPackage module, imported by the pip module to use pyproject-specific hooks here. Don't set it if your project doesn't include a <code>pyproject.toml</code> or your are using a wheel.</li> <li>Tell the buildPythonPackage module to verify that it can import the given python module from our package after a build.</li> <li>Declare a list of requirements for <code>pip</code> to lock by concatenating both the build-systems and normal dependencies in <code>pyproject.toml</code>.</li> <li>By default, the pip module assumes that it finds the top-level package inside the lock file. This isn't the case here as the top-level package comes from the local repository. So we instruct the module to just install all requirements into a flat environment.</li> <li>Declare overrides for package attributes that can't be detected heuristically by dream2nix yet. Here: use pyproject-hooks for click and add <code>poetry-core</code> to its build-time dependencies.</li> </ol>"},{"location":"guides/pip/#build-it_1","title":"Build it","text":"<p>Just as in the same example, we need to lock our python dependencies and add the lock file before we build our package:</p> <pre><code>$ git init\n$ git add flake.nix default.nix\n$ nix run .#default.lock\n[...]\nlock file written to [...]/lock.x86_64-linux.json\nAdd this file to git if flakes is used.\n$ git add lock.json\n$ nix build .#\n$ ./result/bin/my_tool\nHello world!\n</code></pre>"},{"location":"guides/pip/#development-shells","title":"Development Shells","text":"<p>Now that we got <code>my_tool</code> built, let's try out a devShell for it. A shell environment, containing an editable install of our package , all its dependencies and scripts as well as other tools that are useful during development, but shouldn't end up in shipped packages.</p> <p>Notice</p> <p>If you use a flat layout, i.e. your python module is in the top-level of your repo you might discover that you can just import it if you start a python process there. This works because python searches the current directory for modules, but it will miss its dependencies and scripts declared in <code>pyproject.toml</code> won't be on the path.</p> <p>To get started, add the following definition to your <code>flake.nix</code> (it's the same as in the example, so we omit some sections marked with <code>[...]</code>). Click on the pluses to expand annotations in the code below:</p> flake.nix<pre><code>{\n  # [...]\n  outputs = {\n    self,\n    dream2nix,\n    nixpkgs,\n  }: {\n  # [...]\n  devShells = eachSystem (system:\n    let\n      pkgs = nixpkgs.legacyPackages.${system}; # (1)\n      my_tool = self.packages.${system}.default; # (2)\n      python = my_tool.config.deps.python; # (3)\n    in {\n      default = pkgs.mkShell { # (4)\n        inputsFrom = [my_tool.devShell]; # (5)\n        packages = [\n          python.pkgs.python-lsp-server # (6)\n          python.pkgs.python-lsp-ruff\n          python.pkgs.pylsp-mypy\n          python.pkgs.ipython\n\n          pkgs.ruff # (7)\n          pkgs.black\n        ];\n      };\n    });\n  };\n}\n</code></pre> <ol> <li>Get an instance of <code>nixpkgs</code> to use for <code>mkShell</code>, <code>ruff</code>, etc below.</li> <li>Get our default package, <code>my_tool</code> from this flakes outputs...</li> <li>...and a reference to the python interpreter it uses. </li> <li>Call <code>pkgs.mkShell</code> in order to be able to add custom <code>packages</code> or a <code>shellHook</code> to it. You could just use <code>my_tool.devShell</code> here if you are happy with the defaults.</li> <li>Get inputs from <code>mytool.devShell</code>, this includes your package &amp; its dependencies and a <code>shellHook</code> to set up editable installs.</li> <li>Use <code>python.pkgs</code> to get additional python tools into the shell while ensuring that the correct python interpreter is used.</li> <li>Use <code>pkgs</code> to get tools which aren't implemented in python, such as <code>ruff</code> and <code>black</code>.</li> </ol> <p>With that done, let's start a development shell, an ipython interpreter in it, import <code>my_tool</code> and <code>requests</code>, its dependency and see where they are imported from:</p> <pre><code>$ nix develop\nevaluating derivation 'git+file://[path_to_your_repo]#devShells.x86_64-linux.default'\nSome python dependencies of /Users/phaer/src/dream2nix/examples/packages/languages/python-local-development are installed in editable mode\n  my-tool\n    installed at: .\n$ ipython\n[...]\nIn [1]: import my_tool\nIn [2]: my_tool.__file__\nOut[2]: '[path_to_your_repo]/src/my_tool/__init__.py'\nIn [3]: import requests\nIn [4]: requests.__file__\nOut[4]: '/nix/store/[nix hash]-python3-3.11.9-env/lib/python3.11/site-packages/requests/__init__.py'\n</code></pre> <ul> <li><code>my_tool</code> is imported from your repository, as it's an editable install, akin to <code>pip install -e .</code></li> <li><code>requests</code> is loaded from a python environment, generated by our expression above. Changes to it will only be visible after the shell is restarted.</li> </ul> <p>All the other tools declared in our <code>devShell</code> above, i.e. <code>ruff</code> and <code>black</code> should be in <code>PATH</code> and/or <code>PYTHONPATH</code> as well.</p>"},{"location":"reference/nodejs-granular-v3/","title":"nodejs-granular-v3","text":"<p>\ud83d\udc49 Browse Options</p>"},{"location":"reference/nodejs-package-json-v3/","title":"nodejs-package-json-v3","text":"<p>\ud83d\udc49 Browse Options</p>"},{"location":"reference/nodejs-package-lock-v3/","title":"nodejs-package-lock-v3","text":"<p>\ud83d\udc49 Browse Options</p>"},{"location":"reference/php-composer-lock/","title":"php-composer-lock","text":"<p>\ud83d\udc49 Browse Options</p>"},{"location":"reference/php-granular/","title":"php-granular","text":"<p>\ud83d\udc49 Browse Options</p>"},{"location":"reference/pip/","title":"pip","text":"<p>A module to package python projects via pip.</p> <p>Under the hood, it uses ./pkgs/fetchPipMetadata to run <code>pip install --dry-run --report [...]</code> with reproducible inputs and converts the resulting installation report into a dream2nix lock file.</p> <p>Note</p> <p>Due to limitations in <code>pip</code>s cross-platform support, the resulting lock-files are platform-specific! We therefore recommend setting <code>paths.lockFile</code> to <code>lock.${system}.json</code> for all projects where you use the pip module.</p> <p>Check out the pdm module if you need a solution that allows locking for multiple platforms at once!</p> <p>During building, it uses this lock file to build each dependency as well as the top-level package in separate derivations while allowing overrides and further customization via dream2nix module system.</p> <p>\ud83d\udc49 Browse Options</p>"},{"location":"reference-%28experimental%29/WIP-haskell-cabal/","title":"haskell-cabal","text":"<p>\ud83d\udc49 Browse Options</p>"},{"location":"reference-%28experimental%29/WIP-nodejs-builder-v3/","title":"nodejs-builder-v3","text":"<p>\ud83d\udc49 Browse Options</p>"},{"location":"reference-%28experimental%29/WIP-python-pyproject/","title":"python-pyproject","text":"<p>\ud83d\udc49 Browse Options</p>"},{"location":"reference-%28experimental%29/WIP-spago/","title":"spago","text":"<p>\ud83d\udc49 Browse Options</p>"},{"location":"reference-%28experimental%29/python-pdm/","title":"python-pdm","text":"<p>\ud83d\udc49 Browse Options</p>"},{"location":"reference-%28experimental%29/rust-cargo-lock/","title":"rust-cargo-lock","text":"<p>\ud83d\udc49 Browse Options</p>"},{"location":"reference-%28experimental%29/rust-cargo-vendor/","title":"rust-cargo-vendor","text":"<p>\ud83d\udc49 Browse Options</p>"},{"location":"reference-%28experimental%29/rust-crane/","title":"rust-crane","text":"<p>\ud83d\udc49 Browse Options</p>"},{"location":"reference-%28internal%29/WIP-groups/","title":"groups","text":"<p>Module to deal with package sets (so called groups in dream2nix)</p>"},{"location":"reference-%28internal%29/WIP-groups/#separate-different-kinds-of-dependencies","title":"Separate different kinds of dependencies","text":"<p>Many language specific package managers support declaration of different kinds of dependencies like, for example:   - <code>dependencies</code>, <code>devDependencies</code> in nodejs   - <code>dependencies</code>, <code>optional-dependencies.dev</code>, <code>optional-dependencies.test</code>, etc. in python</p> <p>The dream2nix groups module allows to keep the upstream separation by splitting the dependency definitions into different attribute sets located at: <pre><code>config.groups.&lt;group&gt;.packages.&lt;name&gt;.&lt;version&gt;\n</code></pre></p> <p>This separation is relevant because not all dependencies are needed for all targets. A devShell for example requires the dev dependencies, while the runtime environment of the built package does not.</p>"},{"location":"reference-%28internal%29/WIP-groups/#re-use-package-definitions","title":"Re-use package definitions","text":"<p>Each package definition in a group contains two important attributes: - <code>[...].packages.&lt;name&gt;.&lt;version&gt;.module</code>: for the package definition - <code>[...].packages.&lt;name&gt;.&lt;version&gt;.public</code>: for the final evaluated derivation</p> <p>Having the package definition (<code>module</code>) separated from the result allows to re-use the definition elsewhere. For example, a new group could be assembled by referring to the <code>modules</code> of existing groups:</p> <pre><code>{config, dream2nix, ...}: {\n\n  # TODO: This is too complex. Defining a selector function should be enough to\n  #   assemble new groups.\n  # Any specifics about a package other than it's `ecosystem`, `name, `version\n  #   are not important, as everything else is expressed via override modules.\n  # Simply naming the keys of packages should be sufficient to assemble groups.\n\n  # The dev group\n  groups.dev = {\n\n    # a hello package\n    packages.hello.\"1.0.0\".module = {\n      imports = [\n        dream2nix.modules.dream2nix.mkDerivation\n      ];\n      name = \"hello\";\n      version = \"1.0.0\";\n      mkDerivation.buildPhase = lib.mkForce ''echo \"Hello World!\" &gt; $out''\n    };\n\n    # a modified hello package depending on the original hello definition\n    packages.hello-mod.\"1.0.0\".module = {\n      imports = [\n        # import the module definition of `hello` from above\n        config.groups.dev.packages.hello.module\n      ];\n      mkDerivation.buildPhase = ''echo \"Good Bye World!\" &gt; $out'';\n    };\n  };\n\n  # The test group\n  groups.test = {\n\n    # a hello package based on `hello`` from the `dev` group\n    packages.hello.\"1.0.0\".module = {\n      imports = [\n        # import the module definition of `hello` from the `dev` group\n        config.groups.dev.packages.hello.module\n      ];\n      mkDerivation.buildPhase = ''echo \"Happy testing!\" &gt; $out''\n    };\n  }\n}\n</code></pre>"},{"location":"reference-%28internal%29/WIP-groups/#todos","title":"TODOs","text":"<ul> <li>Expose all package candidates somehow (not grouped)</li> <li>Create groups by simply defining <code>selector</code> functions instead of referring to other group's packages modules.</li> </ul> <p>\ud83d\udc49 Browse Options</p>"},{"location":"reference-%28internal%29/buildPythonPackage-mixin/","title":"buildPythonPackage","text":"<p>\ud83d\udc49 Browse Options</p>"},{"location":"reference-%28internal%29/buildPythonPackage/","title":"buildPythonPackage","text":"<p>\ud83d\udc49 Browse Options</p>"},{"location":"reference-%28internal%29/buildRustPackage/","title":"buildRustPackage","text":"<p>\ud83d\udc49 Browse Options</p>"},{"location":"reference-%28internal%29/builtins-derivation/","title":"builtins-derivation","text":"<p>\ud83d\udc49 Browse Options</p>"},{"location":"reference-%28internal%29/mkDerivation-mixin/","title":"mkDerivation-mixin","text":"<p>A package module based on the mkDerivation builder from nixpkgs</p> <p>Equivalent to the dream2nix module <code>mkDerivation</code>, but all options are declared at the toplevel instead of under <code>mkDerivation.[...]</code>.</p> <p>\ud83d\udc49 Browse Options</p>"},{"location":"reference-%28internal%29/mkDerivation/","title":"mkDerivation","text":"<p>A package module based on the mkDerivation builder from nixpkgs</p> <p>\ud83d\udc49 Browse Options</p>"},{"location":"reference-%28internal%29/multi-derivation-package/","title":"multi-derivation-package","text":"<p>\ud83d\udc49 Browse Options</p>"},{"location":"reference-%28internal%29/nodejs-devshell-v3/","title":"nodejs-devshell-v3","text":"<p>\ud83d\udc49 Browse Options</p>"},{"location":"reference-%28internal%29/nodejs-devshell/","title":"nodejs-devshell","text":"<p>\ud83d\udc49 Browse Options</p>"},{"location":"reference-%28internal%29/nodejs-granular/","title":"nodejs-granular","text":"<p>\ud83d\udc49 Browse Options</p>"},{"location":"reference-%28internal%29/nodejs-node-modules-v3/","title":"nodejs-node-modules-v3","text":"<p>\ud83d\udc49 Browse Options</p>"},{"location":"reference-%28internal%29/nodejs-node-modules/","title":"nodejs-node-modules","text":"<p>\ud83d\udc49 Browse Options</p>"},{"location":"reference-%28internal%29/nodejs-package-json/","title":"nodejs-package-json","text":"<p>\ud83d\udc49 Browse Options</p>"},{"location":"reference-%28internal%29/nodejs-package-lock/","title":"nodejs-package-lock","text":"<p>\ud83d\udc49 Browse Options</p>"},{"location":"reference-%28internal%29/overrides/","title":"overrides","text":"<p>\ud83d\udc49 Browse Options</p>"},{"location":"reference-%28internal%29/package-func/","title":"package-func","text":"<p>Module to provide an interface for integrating derivation builder functions like mkDerivation, buildPythonPackage, etc...</p>"},{"location":"reference-%28internal%29/package-func/#package-format","title":"Package format","text":"<p>package-func calls the derivation builder function <code>package-func.func</code> with arguments supplied in <code>package-func.args</code> and wraps the result into the a package that is exposed under <code>config.public</code>. The raw result is avaliable as <code>package-func.result</code>.</p> <p>The final package contains the following attributes:</p> <ul> <li><code>config</code>: the config used to product the existing package</li> <li><code>extendModules</code>: a helper function that allows to extend an existing package with another module</li> <li><code>outputPath</code>: the store path of the result of the default top-level output</li> <li><code>drvPath</code>; the store path of the instantiated derivation of top-level output</li> <li><code>outputName</code>: the name of the default top-level output</li> </ul> <p>In addition, it contains an attribute of the same name for each output declared in <code>package-func.outputs</code>, mapping the output name to the corresponding output of evaluated result.</p>"},{"location":"reference-%28internal%29/package-func/#top-level-output","title":"Top-level output","text":"<p>The top-level output exposed in the final package is selected from <code>package-func.outputs</code>.</p> <p>For a single-output derivations, the sole output is used as the top-level output. For multi-output derivations, the first output specified in outputs or the default output (if the attribute <code>outputSpecified</code> is true) is used as the top-level output.</p> <p>\ud83d\udc49 Browse Options</p>"},{"location":"v1-api/problems/","title":"Problems of the current dream2nix","text":""},{"location":"v1-api/problems/#integration-of-existing-lang2nix-tools","title":"Integration of existing lang2nix tools","text":"<p>Until now, integrating existing 2nix solutions into dream2nix was hard because dream2nix imposed standards which are not met by most existing tools. With v1 we want to lift most of these restrictions to make integration a no-brainer</p> <p>(see sections integrate lang2nix tool (pure) and integrate lang2ix tool (impure).</p>"},{"location":"v1-api/problems/#tied-to-flakes","title":"Tied to flakes","text":"<p>The current api is tied to flakes. The v1 API should not depend on flakes anymore.</p>"},{"location":"v1-api/problems/#composability","title":"Composability","text":"<p>Composability with the current <code>makeFlakeOutputs</code> is bad. Flakes itself aren't nicely composable. Filtering and merging of nested attrsets isn't user friendly.</p> <p>The v1 api will focus on delivering individual derivations, not flakes. While we might provide templates, recommendations, and tools for composition, we should not enforce a specific solution onto the user.</p>"},{"location":"v1-api/problems/#overridability","title":"Overridability","text":"<p>The experience of overriding package- and dependency builds was a bit bumpy so far, as the overriding mechanism was built ontop of override functions provided by nixpkgs' <code>mkDerivation</code>. The v1 API will make use of the nixos module system instead to handle derivation attributes.</p>"},{"location":"v1-api/problems/#discoverability-of-package-options","title":"Discoverability of package options","text":"<p>We want users to be able to inspect the API of an individual package. This will also be made possible by the nixos module system.</p>"},{"location":"v1-api/summary/","title":"dream2nix v1 API","text":"<p>!!! This document does not resemble the current API of dream2nix. It is only a draft and the real implementation differs. More docs will follow.</p> <ul> <li>problems of the current dream2nix</li> <li>users of dream2nix</li> <li>v1 API examples:</li> <li>package maintainers:<ul> <li>project initialization</li> <li>workspaces</li> <li>multiple repos</li> <li>monorepo</li> </ul> </li> <li>consumers:<ul> <li>inspect package options</li> <li>override packages</li> </ul> </li> <li>integration maintainers:<ul> <li>integrate lang2nix tool (pure)</li> <li>integrate lang2nix tool (code-gen/impure)</li> </ul> </li> </ul>"},{"location":"v1-api/users/","title":"The users of dream2nix","text":"<p>The following groups of users are relevant regarding the v1 API design.</p>"},{"location":"v1-api/users/#integration-maintainers-level1","title":"Integration Maintainers (Level1)","text":"<p>People who use dream2nix to maintain language2nix integrations</p>"},{"location":"v1-api/users/#package-maintainers-level2","title":"Package Maintainers (Level2)","text":"<p>People who use dream2nix to maintain nix derivations for packages</p>"},{"location":"v1-api/users/#consumers-level3","title":"Consumers (Level3)","text":"<p>People who use and customize packages created via dream2nix</p>"},{"location":"v1-api/consuming/inspect-options/","title":"Inspect the API of a package","text":"<p>Downstream users can inspect the api of any consumed package as well as raw package modules</p>"},{"location":"v1-api/consuming/inspect-options/#load-the-dream2nix-shell","title":"Load the dream2nix shell","text":"<pre><code>nix-shell https://dream2nix.dev -A devShells.default\n</code></pre>"},{"location":"v1-api/consuming/inspect-options/#get-manual-of-package-module","title":"Get manual of package module","text":"<p>Assuming a package module in <code>./upstream/my-package.nix</code></p> <pre><code>$ dream2nix man ./upstream/my-package.nix\n</code></pre>"},{"location":"v1-api/consuming/inspect-options/#get-manual-of-derivation","title":"Get manual of derivation","text":"<p>Assuming derivations defined via <code>./upstream/default.nix</code></p> <pre><code>dream2nix man ./upstream/default.nix -A packages.my-package\n</code></pre>"},{"location":"v1-api/consuming/inspect-options/#get-manual-of-flake-attribute","title":"Get manual of flake attribute","text":"<p>Assuming derivations defined via a flake on github</p> <pre><code>dream2nix man github:user/repo#some-package\n</code></pre>"},{"location":"v1-api/consuming/override/","title":"Consume and modify dream2nix packages","text":""},{"location":"v1-api/consuming/override/#given-the-following-package","title":"Given the following package","text":"<p><code>upstream/my-package.nix</code> <pre><code>{config, lib, dream2nix, ...}: {\n\n  imports = [\n    dream2nix.modules.nodejs.mkDerivation\n    dream2nix.modules.nodejs.package-lock\n  ];\n\n  pname = \"my-package\";\n  version = \"2.0.0\";\n\n  src = {\n    type = github;\n    owner = \"my-user\";\n    repo = \"my-repo\";\n    ref = config.version;\n    hash = \"sha256-mia90VYv/YTdWNhKpvwvFW9RfbXZJSWhJ+yva6EnLE8=\";\n  };\n\n  # declare dependency on python3\n  deps = {nixpkgs, ...}: {\n    python3 = nixpkgs.python313;\n  };\n\n  nativeBuildInputs = [\n    config.deps.python3\n  ];\n\n  configurePhase = ''\n    python3 --version\n  '';\n\n  buildPhase = ''\n    python3 -c 'print(\"Hello World!\")' &gt; $out\n  '';\n}\n</code></pre></p> <p><code>upstream/default.nix</code> <pre><code>{\n  nixpkgs ? import &lt;nixpkgs&gt; {},\n  dream2nix ?\n    import\n    (builtins.fetchTarball \"https://dream2nix.dev/tarball/1.0\")\n    {inherit nixpkgs;},\n}: {\n  packages.my-package = dream2nix.eval ./my-package.nix;\n}\n</code></pre></p>"},{"location":"v1-api/consuming/override/#1-override-using-modules","title":"1. Override using modules","text":""},{"location":"v1-api/consuming/override/#11-define-a-module-for-the-override","title":"1.1 Define a module for the override","text":"<p><code>my-package-override.nix</code> <pre><code>{config, lib, ... }: {\n\n  version = \"2.1.0\";\n\n  # No need to re-define other fetcher attributes.\n  # The module system updates them for us.\n  src.hash = \"sha256-LM5GDNjLcmgZVQEeANWAOO09KppwGaYEzJBjYmuSwys=\";\n\n  deps = {nixpkgs, ...}: {\n\n    # change the python version\n    python3 = lib.mkForce nixpkgs.python310;\n\n    # add a dependency on hello  \n    hello = nixpkgs.hello;\n  };\n\n  # add hello to nativeBuildInputs\n  # (`oldAttrs.nativeBuildInputs + ...` not needed here)\n  nativeBuildInputs = [\n    config.deps.hello\n  ];\n\n  # add lines to configurePhase\n  postConfigure = ''\n    hello --version\n  '';\n\n  # replace the build phase via mkForce\n  buildPhase = lib.mkForce \"\n    hello &gt; $out\n  \";\n}\n</code></pre></p>"},{"location":"v1-api/consuming/override/#12-apply-my-package-overridenix-via-extendmodules","title":"1.2 Apply <code>my-package-override.nix</code> via extendModules","text":"<p>Using <code>extendModules</code> is simple. It allows to extend an existing package with another module. This doesn't require knowledge about the original modules that went into the package.</p> <p><code>./default.nix</code> <pre><code>let\n  nixpkgs = import &lt;nixpkgs&gt; {};\n  upstream = import ./upstream {inherit nixpkgs;};\n  my-package = upstream.packages.my-package;\n\n  # The recommended way of modifying a package is using extendModules,\n  #    which uses the module systems merge logic to apply changes.\n  my-package-extended = my-package.extendModules {\n    modules = [./my-package-override.nix];\n  };\n\nin {\n  inherit my-package-extended;\n}\n</code></pre></p>"},{"location":"v1-api/consuming/override/#13-or-apply-my-package-overridenix-via-dream2nixeval","title":"1.3 Or apply <code>my-package-override.nix</code> via dream2nix.eval","text":"<p>This approach is a bit cleaner. It doesn't introduce a chain of extendModules function calls. This style also makes it obvious which modules went into the package. Though, this requires access to the original <code>my-package.nix</code> module and knowledge about the <code>packageSets</code> that went into it.</p> <p><code>default.nix</code> <pre><code>{\n  nixpkgs ? import &lt;nixpkgs&gt; {},\n  dream2nix ?\n    import\n    (builtins.fetchTarball \"https://dream2nix.dev/tarball/1.0\")\n    {inherit nixpkgs;},\n\n}: let\n\n  my-package-extended = dream2nix.eval\n    {packagetSets = {inherit nixpkgs;};}\n    [\n      ./upstream/my-package.nix\n      ./my-package-override.nix\n    ];\n\nin {\n  my-package-extended\n}\n</code></pre></p>"},{"location":"v1-api/consuming/override/#2-override-package-via-overrideattrs-functions","title":"2. Override package via <code>override[Attrs]</code> functions","text":"<p>It is recommended to use modules for overriding, like described above, but for backward compatibility, <code>overrideAttrs</code> and <code>override</code> are still supported.</p> <pre><code>let\n  nixpkgs = import &lt;nixpkgs&gt; {};\n  upstream = import ./upstream {inherit nixpkgs;};\n  my-package = upstream.packages.my-package;\n\n  # Override the package via `override` and `overrideAttrs`\n  my-package-overridden' = my-package.override\n    (oldAttrs: {\n\n      # change the python version\n      python3 = nixpkgs.python310;\n    });\n\n  my-package-overridden = my-package-overridden'.overrideAttrs\n    (oldAttrs: rec {\n\n      version = \"2.1.0\";\n\n      src = nixpkgs.fetchFromGithub {\n        owner = \"my-owner\";\n        repo = \"my-repo\";\n        ref = version;\n        hash = \"sha256-LM5GDNjLcmgZVQEeANWAOO09KppwGaYEzJBjYmuSwys=\";\n      };\n\n      # add hello to nativeBuildInputs\n      nativeBuildInputs = [\n        nixpkgs.hello\n      ];\n\n      # add lines to configurePhase\n      postConfigure = ''\n        hello --version\n      '';\n\n      # replace the build phase\n      buildPhase = ''\n        hello &gt; $out\n      '';\n    });\n\nin {\n  inherit my-package-overridden;\n}\n</code></pre>"},{"location":"v1-api/integrating/integrate-lang2nix-impure/","title":"Integrate lang2nix tool (impure/code-gen)","text":"<p>We use gomod2nix as an example here to demonstrate creating a dream2nix integration.</p> <p>Gomod2nix is a nix code generator that requires network access, a great example for an impure dream2nix integration.</p> <p><code>dream2nix/modules/go.gomod2nix.nix</code> <pre><code>{config, lib, dream2nix, system, ...}: rec {\n\n  imports = [\n\n    # import generic mkDerivation interface, which will add options like:\n    #   - buildInputs\n    #   - nativeBuildInputs\n    #   - ...\n    dream2nix.modules.mkDerivation-interfaces\n\n    # Generic interface for impure lang2nix tools (code generators)\n    #   This provides options like `generateBin` (see below)\n    dream2nix.modules.integrations.impure\n  ];\n\n  options = {\n    modules = lib.mkOption {\n      description = \"The path to the gomod2nix.toml\";\n      type = lib.types.str;\n      default = \"${config.dream2nix.artifactsLocation}/gomod2nix.toml\" ;\n    };\n\n  };\n\n  config = {\n    # Generated code will end up in:\n    #   {repo}/dream2nix/artifacts/{engineName}/{package_identifier}\n    dream2nix.engineName = \"gomod2nix\";\n\n    # An executable that generates nix code for the given `src`\n    dream2nix.generateBin = dream2nix.utils.writePureShellScript \"gomod2nix-generate.sh\"\n      [\n        # add gomod2nix tool to PATH\n        dream2nix.inputs.gomod2nix.packages.${system}.gomod2nix\n      ]\n      ''\n        targetDir=$1\n        gomod2nix --dir \"${config.src}\" --outdir \"$targetDir\"\n      '';\n\n    # signal that all options should be passed to the final derivation function\n    argsForward = l.mapAttrs (_: _: true) options;\n\n    # the final derivation is built by calling gomod2nix.buildGoApplication\n    config.final.derivation =\n      dream2nix.inputs.gomod2nix.lib.${system}.buildGoApplication\n      config.final.derivation-args;\n  };\n}\n</code></pre></p>"},{"location":"v1-api/integrating/integrate-lang2nix-pure/","title":"Integrate lang2nix tool (pure)","text":"<p>We use crane as an example here to demonstrate creating a dream2nix integration</p> <p><code>dream2nix/modules/rust.crane-buildPackage.nix</code> <pre><code>{config, lib, dream2nix, system, ...}: rec {\n\n  imports = [\n    # import generic mkDerivation interface, which will add options like:\n    #   - buildInputs\n    #   - nativeBuildInputs\n    #   - ...\n    dream2nix.modules.mkDerivation-interfaces\n  ];\n\n  options = {\n    buildPhaseCargoCommand = lib.mkOption {\n      description = \"A command to run during the derivation's build phase. Pre and post build hooks will automatically be run.\";\n      type = lib.types.nullOr lib.types.str;\n      default = null;\n    };\n    cargoArtifacts = lib.mkOption {\n      description = \"A path (or derivation) which contains an existing cargo target directory, which will be reused at the start of the derivation. Useful for caching incremental cargo builds.\";\n      type = lib.types.nullOr lib.types.str;\n      default = null;\n    };\n    cargoBuildCommand = lib.mkOption {\n      description = \"A cargo invocation to run during the derivation's build phase\";\n      type = lib.types.nullOr lib.types.str;\n      default = null;\n    }\n\n    # ... more options of crane's buildPackage\n  };\n\n  config = {\n    # signal that all options should be passed to the final derivation function\n    argsForward = l.mapAttrs (_: _: true) options;\n\n    # the final derivation is built by calling crane.buildPackage\n    config.final.derivation =\n      dream2nix.inputs.crane.lib.${system}.buildPackage\n      config.final.derivation-args;\n  };\n}\n</code></pre></p>"},{"location":"v1-api/packaging/monorepo/","title":"build packages in a monorepo","text":"<p>The example mono repo has 3 packages: <code>nodejs-app</code>, <code>python-tool</code>, <code>rust-tool</code>.</p> <p>The packages <code>python-tool</code> and <code>rust-tool</code> might or might not be built with dream2nix.</p> <p>The package <code>nodejs-app</code> is built with dream2nix and depends on <code>python-tool</code> and <code>rust-tool</code>.</p>"},{"location":"v1-api/packaging/monorepo/#assuming-this-repo-structure","title":"Assuming this repo structure","text":"<pre><code>\u251c\u2500\u2500 default.nix\n\u251c\u2500\u2500 overrides\n\u2502  \u251c\u2500\u2500 nodejs\n\u2502  \u251c\u2500\u2500 python\n\u2502  \u2514\u2500\u2500 rust\n\u251c\u2500\u2500 nodejs-app\n\u2502  \u2514\u2500\u2500 default.nix\n\u251c\u2500\u2500 python-tool\n\u2502  \u2514\u2500\u2500 default.nix\n\u2514\u2500\u2500 rust-tool\n   \u2514\u2500\u2500 default.nix\n</code></pre>"},{"location":"v1-api/packaging/monorepo/#contents-of-nodejs-appdefaultnix","title":"Contents of <code>./nodejs-app/default.nix</code>","text":"<p><code>./nodejs-app/default.nix</code> <pre><code>{config, lib, dream2nix, ...}: {\n\n  imports = [\n    # default module to create a nodejs package\n    dream2nix.modules.nodejs.mkDerivation\n    # get package dependencies from package-lock\n    dream2nix.modules.nodejs.package-lock\n  ];\n\n  # Overrides allow to manipulate dependency builds\n  overrides.local.path = ../overrides/nodejs;\n\n  src = ./.;\n\n  # include dependencies from nixpkgs and the local monorepo\n  # see definition of `packageSets` in ../default.nix\n  deps = {nixpkgs, monorepo, ...} @ packageSets: {\n    inherit (nixpkgs)\n      hello\n      ;\n    inherit (monorepo)\n      python-tool\n      rust-tool\n      ;\n  };\n\n  nativeBuildInputs = [\n    config.deps.hello\n    config.deps.python-tool\n    config.deps.rust-tool\n  ];\n\n  configurePhase = ''\n    hello --version\n    python-tool --version\n    rust-tool --version\n  '';\n\n  # add more mkDerivation attributes here to customize...\n}\n</code></pre></p>"},{"location":"v1-api/packaging/monorepo/#contents-of-defaultnix","title":"Contents of <code>./default.nix</code>","text":"<p><code>./default.nix</code> <pre><code>{\n  nixpkgs ? import &lt;nixpkgs&gt; {},\n  dream2nix ?\n    import\n    (builtins.fetchTarball \"https://dream2nix.dev/tarball/1.0\")\n    {inherit nixpkgs;},\n\n} @ inputs: let\n\n  makePackage = modules: dream2ix.mkDerivation\n    # Package sets available to each package's `deps` function\n    {packageSets = {inherit monorepo nixpkgs;};}\n    modules;\n\n  monorepo = {\n    nodejs-app = makePackage ./nodejs-app;\n    python-tool = makePackage ./python-tool;\n    rust-tool = makePackage ./rust-tool;\n  };\n\nin {\n  packages = monorepo;\n}\n</code></pre></p>"},{"location":"v1-api/packaging/nodejs-init-project/","title":"initialize nodejs project + dev shell","text":""},{"location":"v1-api/packaging/nodejs-init-project/#load-shell-with-nodejs-npm","title":"load shell with nodejs + npm","text":"<p><code>``console tesh-session=\"next-app\" tesh-setup=\"setup.sh\" $ nix-shell -p https://dream2nix.dev -A devShells.nodejs <pre><code>## create my-app\n```console tesh-session=\"next-app\"\nnpx create-next-app my-app\n</code></pre> This creates</code>./my-app/package.json<code>and more, using</code>create-next-app` as a helper.</p>"},{"location":"v1-api/packaging/nodejs-init-project/#create-my-appnix","title":"create <code>my-app.nix</code>","text":"<p><code>my-app.nix</code> <pre><code>{config, lib, dream2nix, ...}: {\n\n  imports = [\n    # default module to create a nodejs package\n    dream2nix.modules.nodejs.mkDerivation\n    # get package dependencies from package-lock\n    dream2nix.modules.nodejs.package-lock\n  ];\n\n  # Allows to manipulate dependency builds\n  overrides.local.path = ./overrides;\n\n  src = ./my-app;\n\n  # add more mkDerivation attributes here to customize...\n}\n</code></pre></p>"},{"location":"v1-api/packaging/nodejs-init-project/#create-my-app-shellnix-for-your-dev-shell","title":"create <code>my-app-shell.nix</code> for your dev shell","text":"<p><code>my-app-shell.nix</code> <pre><code>{config, lib, dream2nix, ...}: {\n\n  imports = [\n    # the default dev shell for nodejs\n    dream2nix.modules.nodejs.mkShell\n    # adds dependencies of my-app to the dev shell\n    dream2nix.modules.nodejs.package-lock\n  ];\n\n  src = ./my-app;\n\n  # include hello from nixpkgs.\n  # `deps` is the single source of truth for inputs from the `outside world`.\n  # `deps` will later allow us to safely override any dependency.\n  deps = {nixpkgs, ...}: {\n    inherit (nixpkgs) hello;\n  };\n\n  # add hello from nixpkgs to the dev shell\n  buildInputs = [\n    config.deps.hello\n  ]\n}\n</code></pre></p>"},{"location":"v1-api/packaging/nodejs-init-project/#create-defaultnix-entry-point","title":"create <code>default.nix</code> entry point","text":"<p><code>default.nix</code> <pre><code>{\n  nixpkgs ? import &lt;nixpkgs&gt; {},\n  dream2nix ?\n    import\n    (builtins.fetchTarball \"https://dream2nix.dev/tarball/1.0\")\n    {inherit nixpkgs;},\n}: {\n  packages.my-app = dream2nix.eval ./my-app.nix;\n  devShells.my-app = dream2nix.eval ./my-app-shell.nix;\n}\n</code></pre></p>"},{"location":"v1-api/packaging/nodejs-init-project/#build-my-app","title":"build my-app","text":"<pre><code>nix-build -f ./default.nix -A packages.my-app\n</code></pre>"},{"location":"v1-api/packaging/nodejs-init-project/#create-shellnix-used-by-nix-shell-command","title":"create <code>shell.nix</code> (used by <code>nix-shell</code> command)","text":"<p><code>shell.nix</code> <pre><code>(import ./default.nix {}).devShells.my-app\n</code></pre> Enter the dev shell: <pre><code>nix-shell\n</code></pre> all dependencies of my-app are available</p>"},{"location":"v1-api/packaging/nodejs-init-project/#fix-build-of-dependencies-via-overrides","title":"fix build of dependencies via <code>./overrides/</code>","text":"<p>Files in <code>./overrides/</code> must always be named like the package they apply to.</p> <p>Example: <code>./overrides/keytar.nix</code></p>"},{"location":"v1-api/packaging/nodejs-init-project/#_1","title":"initialize nodejs project + dev shell","text":"<pre><code>{config, ...}: {\n\n  # include dependencies from nixpkgs.\n  deps = {nixpkgs, ...}: {\n    inherit (nixpkgs) \n      libsecret\n      pkg-config\n      ;\n  };\n\n  # add build time dependencies\n  nativeBuildInputs = [\n    config.deps.libsecret\n    config.deps.pkg-config\n  ];\n}\n</code></pre> <p>Scoped package example: <code>./overrides/@babel/core.nix</code></p>"},{"location":"v1-api/packaging/nodejs-init-project/#_2","title":"initialize nodejs project + dev shell","text":"<pre><code>{config, ...}: {\n  # ...\n}\n</code></pre>"},{"location":"v1-api/packaging/nodejs-multiple-repos/","title":"handle multiple repos","text":"<p>Assuming that <code>./repo1</code> and <code>./repo2</code> are separate git repositories.</p> <p>Both repos have a single package <code>repo1/my-app</code> and <code>repo2/my-tool</code>.</p> <p>In order to build <code>repo1/my-app</code> we need <code>repo2/my-tool</code> as a build time dependency.</p> <p>The following structure is assumed: <pre><code>\u251c\u2500\u2500 repo1\n\u2502  \u251c\u2500\u2500 default.nix\n\u2502  \u2514\u2500\u2500 my-app.nix\n\u2514\u2500\u2500 repo2\n   \u251c\u2500\u2500 default.nix\n   \u2514\u2500\u2500 my-tool.nix\n</code></pre></p>"},{"location":"v1-api/packaging/nodejs-multiple-repos/#contents-of-repo1my-appnix","title":"contents of <code>repo1/my-app.nix</code>","text":"<p><code>repo1/my-app.nix</code> <pre><code>{config, lib, dream2nix, ...}: {\n\n  imports = [\n    dream2nix.modules.nodejs.mkDerivation\n    dream2nix.modules.nodejs.package-lock\n  ];\n\n  src = ./.;\n\n  # include my-tool from repo2\n  deps = {repo2, ...}: {\n    inherit (repo2) my-tool;\n  };\n\n  # add my-tool as build time dependency\n  nativeBuildInputs = [\n    config.deps.my-tool\n  ];\n\n  # use my-tool to build my-app\n  buildPhase = ''\n    my-tool build\n    echo \"done building\"\n  '';\n}\n</code></pre></p>"},{"location":"v1-api/packaging/nodejs-multiple-repos/#contents-of-repo1defaultnix","title":"contents of <code>repo1/default.nix</code>","text":"<p><code>repo1/default.nix</code> <pre><code>{\n  pkgs ? import &lt;nixpkgs&gt; {},\n  dream2nix ?\n    import\n    (builtins.fetchTarball \"https://dream2nix.dev/tarball/1.0\")\n    {inherit pkgs;},\n}: {\n  packages.my-app = dream2nix.eval\n    {\n      packageSets.nixpkgs = pkgs;\n\n      # fetchGit could be used here alternatively\n      packageSets.repo2 = import ../repo2/default.nix {};\n    }\n    ./my-app.nix;\n}\n</code></pre></p>"},{"location":"v1-api/packaging/nodejs-workspaces/","title":"build + develop on nodejs workspaces","text":""},{"location":"v1-api/packaging/nodejs-workspaces/#assuming-a-packagejson-with-workspaces","title":"assuming a <code>package.json</code> with workspaces","text":"<p><code>package.json</code> <pre><code>{\n  \"name\": \"my-workspaces\",\n  \"workspaces\": [\n    \"my-tool\"\n    \"my-first-app\"\n    \"my-second-app\"\n  ]\n}\n</code></pre></p>"},{"location":"v1-api/packaging/nodejs-workspaces/#define-package-set-via-workspacesnix","title":"define package set via <code>workspaces.nix</code>","text":"<pre><code>{config, lib, dream2nix, ...}: {\n\n  imports = [\n    dream2nix.modules.nodejs.workspaces\n    dream2nix.modules.nodejs.package-lock\n  ];\n\n  src = ./.;\n\n  # Allows to manipulate builds of workspace members and their dependencies\n  overrides.local.path = ./overrides;\n}\n</code></pre>"},{"location":"v1-api/packaging/nodejs-workspaces/#create-defaultnix-entry-point","title":"create <code>default.nix</code> entry point","text":"<p><code>default.nix</code> <pre><code>{\n  nixpkgs ? import &lt;nixpkgs&gt; {},\n  dream2nix ?\n    import\n    (builtins.fetchTarball \"https://dream2nix.dev/tarball/1.0\")\n    {inherit nixpkgs;},\n}: {\n  packages = {\n    inherit (dream2nix.lib.mkPackageSet ./workspaces.nix)\n      my-tool\n      my-first-app\n      my-second-app\n      ;\n  };\n}\n</code></pre></p>"},{"location":"v1-api/packaging/nodejs-workspaces/#configure-package-builds-via-overrides","title":"configure package builds via <code>./overrides/</code>","text":"<p>Files in <code>./overrides/</code> must always be named like the the package they apply to.</p> <p>Manipulate my-tool via <code>./overrides/my-tool.nix</code> <pre><code>{config, ...}: {\n\n  # include python from nixpkgs\n  deps = {nixpkgs, ...}: {\n    inherit (nixpkgs) python;\n  };\n\n  buildInputs = [\n    config.deps.python\n  ];\n}\n</code></pre></p> <p>Manipulate my-first-app via <code>./overrides/my-first-app.nix</code> <pre><code>{config, ...}: {\n\n  # include my-tool from the local workspace\n  deps = {workspace, ...}: {\n    inherit (workspace) my-tool;\n  };\n\n  buildInputs = [\n    config.deps.my-tool\n  ];\n}\n</code></pre></p>"}]}